import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a,o as n}from"./app-BE26t00W.js";const t={};function e(h,i){return n(),l("div",null,i[0]||(i[0]=[a(`<h2 id="redis-基础概念" tabindex="-1"><a class="header-anchor" href="#redis-基础概念"><span>Redis 基础概念</span></a></h2><ul><li><strong>Redis 是什么？</strong><ul><li>Redis（Remote Dictionary Server）是一个开源的键值存储系统，支持多种数据结构，如字符串、哈希、列表、集合和有序集合。它以其高性能和丰富的功能而著称。</li></ul></li></ul><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h3><ul><li><p><strong>Redis 中常见的数据类型有哪些？</strong></p><ul><li>常见的数据类型包括： <ul><li><strong>String</strong>：字符串。</li><li><strong>Hash</strong>：哈希表。</li><li><strong>List</strong>：列表。</li><li><strong>Set</strong>：集合。</li><li><strong>Sorted Set</strong>：有序集合。</li></ul></li></ul></li><li><p><strong>Redis 的 hash 是什么？</strong></p><ul><li>Hash是键值对的集合，适用于存储对象。例如，可以存储用户信息。</li></ul></li><li><p><strong>Redis 中的 List 类型的常见操作命令有哪些？</strong></p><ul><li>常见操作命令包括： <ul><li><code>LPUSH</code>：从左边插入元素。</li><li><code>RPUSH</code>：从右边插入元素。</li><li><code>LPOP</code>：从左边弹出元素。</li><li><code>RPOP</code>：从右边弹出元素。</li><li><code>LRANGE</code>：获取列表中的多个元素。</li></ul></li></ul></li><li><p><strong>如何在 Redis 中实现队列和栈数据结构？</strong></p><ul><li>使用List类型实现队列和栈： <ul><li><strong>队列</strong>：使用<code>LPUSH</code>和<code>RPOP</code>。</li><li><strong>栈</strong>：使用<code>LPUSH</code>和<code>LPOP</code>。</li></ul></li></ul></li><li><p><strong>Redis 中的 ListPack 数据结构是什么？</strong></p><ul><li><strong>ListPack</strong>：Redis 6.0引入的一种新的数据结构，用于优化小对象的存储，类似于Ziplist。</li><li><strong>特点</strong>：占用内存更少，性能更好。</li></ul></li><li><p><strong>Redis 字符串类型的最大值大小是多少？</strong></p><ul><li>Redis字符串类型的最大值大小为512MB。</li></ul></li><li><p><strong>Redis 中 EMBSTR 对象的阈值设置为何为 44？其调整历史是什么？</strong></p><ul><li><strong>EMBSTR对象</strong>：用于存储小于等于44字节的字符串，直接存储在SDS结构中，减少内存碎片。</li><li><strong>调整历史</strong>：早期版本中，EMBSTR对象的阈值为39字节，后来调整为44字节，以优化内存使用。</li></ul></li><li><p><strong>Redis 中的 Geo 数据结构是什么？</strong></p><ul><li>Geo数据结构用于存储地理位置信息，支持地理查询操作，如距离计算、半径搜索等。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">geoadd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;places&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GeoCoordinate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">13.361389</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">38.115556</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Sicily&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="数据结构实现" tabindex="-1"><a class="header-anchor" href="#数据结构实现"><span>数据结构实现</span></a></h3><ul><li><strong>Redis String 类型的底层实现是什么？</strong><ul><li>Redis String类型底层使用SDS（Simple Dynamic String）实现，它是Redis自定义的动态字符串。</li></ul></li><li><strong>Redis 中的 Ziplist 和 Quicklist 数据结构的特点是什么？</strong><ul><li><strong>Ziplist</strong>：压缩列表，用于存储多个小对象，节省内存。</li><li><strong>Quicklist</strong>：快速列表，由多个Ziplist组成，用于存储大量数据。</li></ul></li></ul><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h3><ul><li><strong>Redis 中有哪些内存淘汰策略？</strong><ul><li>常见的内存淘汰策略包括： <ul><li><strong>noeviction</strong>：不淘汰数据，达到最大内存限制时返回错误。</li><li><strong>allkeys-lru</strong>：使用LRU算法淘汰任意键。</li><li><strong>volatile-lru</strong>：使用LRU算法淘汰设置了过期时间的键。</li><li><strong>allkeys-random</strong>：随机淘汰任意键。</li><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的键。</li><li><strong>volatile-ttl</strong>：优先淘汰TTL值最小的键。</li></ul></li></ul></li><li><strong>Redis 中的内存碎片化是什么？如何进行优化？</strong><ul><li><strong>内存碎片化</strong>：由于频繁的内存分配和释放，导致内存空间分散。</li><li><strong>优化方法</strong>： <ul><li><strong>重启Redis</strong>：定期重启Redis实例，回收内存。</li><li><strong>调整内存分配策略</strong>：使用更合理的内存分配策略。</li><li><strong>使用内存碎片整理工具</strong>：使用第三方工具进行内存碎片整理。</li></ul></li></ul></li></ul><h3 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化"><span>持久化</span></a></h3><ul><li><strong>Redis 的持久化机制有哪些？</strong><ul><li>常见的持久化机制包括： <ul><li><strong>RDB</strong>：定期将内存中的数据快照保存到磁盘。</li><li><strong>AOF</strong>：记录服务器执行的所有写操作命令，以便恢复数据。</li></ul></li></ul></li><li><strong>Redis 在生成 RDB 文件时如何处理请求？</strong><ul><li>生成RDB文件时，Redis会创建一个子进程来执行快照操作，父进程继续处理请求，子进程完成后将快照文件写入磁盘。</li></ul></li></ul><h3 id="击穿-穿透-雪崩" tabindex="-1"><a class="header-anchor" href="#击穿-穿透-雪崩"><span>击穿/穿透/雪崩</span></a></h3><ul><li><strong>Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？</strong><ul><li><strong>缓存击穿</strong>：某个热点Key突然大量请求，导致缓存失效，所有请求直接打到数据库。</li><li><strong>缓存穿透</strong>：查询一个不存在的Key，导致每次查询都直接打到数据库。</li><li><strong>缓存雪崩</strong>：大量缓存在同一时间失效，导致所有请求直接打到数据库。</li></ul></li><li><strong>Redis 中如何保证缓存与数据库的数据一致性？</strong><ul><li>常见的方法包括： <ul><li><strong>双写</strong>：同时写入缓存和数据库。</li><li><strong>失效时间</strong>：为缓存设置合理的失效时间。</li><li><strong>缓存更新策略</strong>：使用更新或删除策略保持缓存和数据库一致。</li></ul></li></ul></li></ul><h3 id="大key和热点key" tabindex="-1"><a class="header-anchor" href="#大key和热点key"><span>大Key和热点Key</span></a></h3><ul><li><strong>Redis 中的 Big Key 问题是什么？如何解决？</strong><ul><li><strong>Big Key问题</strong>：大Key占用大量内存，影响Redis性能。</li><li><strong>解决方法</strong>： <ul><li><strong>分片</strong>：将大Key拆分成多个小Key。</li><li><strong>使用更合适的数据结构</strong>：例如使用Ziplist或Hash。</li></ul></li></ul></li><li><strong>如何解决 Redis 中的热点 key 问题？</strong><ul><li><strong>热点Key问题</strong>：某些Key被频繁访问，导致性能瓶颈。</li><li><strong>解决方法</strong>： <ul><li><strong>数据分片</strong>：将热点Key分散到多个节点。</li><li><strong>缓存层</strong>：在应用层或CDN层缓存热点Key。</li><li><strong>布隆过滤器</strong>：减少不必要的查询。</li></ul></li></ul></li></ul><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h3><ul><li><p><strong>Redis 中如何实现分布式锁？</strong></p><ul><li>可以使用Redis的<code>SETNX</code>命令实现简单的分布式锁。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁成功，执行业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">del</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>分布式锁在未完成逻辑前过期怎么办？</strong></p><ul><li>可以在设置锁时设置一个合理的超时时间，并在释放锁时进行双重检查。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> expireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 30秒超时</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(expireTime))</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁成功</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> existingExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (existingExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(existingExpireTime)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 锁已过期，尝试重新获取锁</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> currentExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(expireTime));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">currentExpireTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(existingExpireTime)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 成功获取锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Redis 的 Red Lock 是什么？你了解吗？</strong></p><ul><li>Red Lock是一种改进的分布式锁算法，通过多个Redis实例来提高锁的可靠性和可用性。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisson </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Redis 实现分布式锁时可能遇到的问题有哪些？</strong></p><ul><li>常见问题包括： <ul><li><strong>锁过期</strong>：锁在业务逻辑未完成前过期。</li><li><strong>死锁</strong>：多个节点竞争锁导致死锁。</li><li><strong>网络分区</strong>：网络问题导致锁无法正常释放。</li></ul></li></ul></li><li><p><strong>说说 Redisson 分布式锁的原理？</strong></p><ul><li><strong>Redisson分布式锁</strong>：基于Redis实现的分布式锁，提供了丰富的功能和更高的可靠性。</li><li><strong>原理</strong>： <ul><li><strong>可重入锁</strong>：支持可重入，多次获取锁不会阻塞。</li><li><strong>公平锁</strong>：支持公平锁，按请求顺序获取锁。</li><li><strong>锁过期保护</strong>：通过WatchDog机制自动续期，防止锁过期。</li></ul></li><li><strong>使用示例</strong>：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisson </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="性能及应用场景" tabindex="-1"><a class="header-anchor" href="#性能及应用场景"><span>性能及应用场景</span></a></h2><ul><li><strong>Redis 通常应用于哪些场景？</strong><ul><li>常见的应用场景包括： <ul><li><strong>缓存</strong>：作为高速缓存层，提高数据访问速度。</li><li><strong>消息队列</strong>：实现消息传递和任务队列。</li><li><strong>会话存储</strong>：存储用户会话信息。</li><li><strong>计数器</strong>：统计网站访问量、用户行为等。</li><li><strong>排行榜</strong>：实现实时排行榜功能。</li><li><strong>地理位置</strong>：存储和查询地理位置信息。</li></ul></li></ul></li></ul><h3 id="快-源码设计" tabindex="-1"><a class="header-anchor" href="#快-源码设计"><span>快/源码设计</span></a></h3><ul><li><p><strong>Redis 为什么这么快？</strong></p><ul><li>Redis之所以快，主要有以下几个原因： <ul><li><strong>内存存储</strong>：数据存储在内存中，访问速度快。</li><li><strong>单线程模型</strong>：避免了多线程间的上下文切换开销。</li><li><strong>高效的内存管理</strong>：使用自定义的数据结构和内存分配算法。</li><li><strong>网络通信优化</strong>：使用多路复用IO模型，处理大量并发连接。</li></ul></li></ul></li><li><p><strong>Redis 源码中有哪些巧妙的设计，举几个典型的例子？</strong></p><ul><li><strong>内存管理</strong>：使用自定义的内存分配器，减少内存碎片。</li><li><strong>多路复用IO</strong>：使用epoll/kqueue等高性能IO多路复用技术。</li><li><strong>事件驱动</strong>：使用事件驱动模型，处理大量并发连接。</li><li><strong>数据结构优化</strong>：使用Ziplist、Quicklist等优化数据结构，减少内存占用。</li></ul></li></ul><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化"><span>性能优化</span></a></h3><ul><li><strong>Redis 性能瓶颈时如何处理？</strong><ul><li>常见的性能优化方法包括： <ul><li><strong>增加内存</strong>：扩大Redis实例的内存容量。</li><li><strong>优化数据结构</strong>：选择合适的数据结构，减少内存占用。</li><li><strong>使用Pipeline</strong>：减少网络往返次数，提高性能。</li><li><strong>分片</strong>：将数据分散到多个Redis实例。</li><li><strong>监控和调优</strong>：使用监控工具定期检查性能，进行调优。</li></ul></li></ul></li></ul><h3 id="多线程和虚拟内存" tabindex="-1"><a class="header-anchor" href="#多线程和虚拟内存"><span>多线程和虚拟内存</span></a></h3><ul><li><p><strong>为什么 Redis 设计为单线程？6.0 版本为何引入多线程？</strong></p><ul><li><strong>单线程设计</strong>：避免多线程间的上下文切换开销，提高性能。</li><li><strong>6.0版本引入多线程</strong>：为了处理IO密集型任务，如网络IO和文件IO，提高整体性能。</li></ul></li><li><p><strong>Redis 的虚拟内存（VM）机制是什么？</strong></p><ul><li><strong>虚拟内存机制</strong>：允许Redis将部分数据换出到磁盘，减少内存占用。</li><li><strong>工作原理</strong>：Redis将不常用的数据换出到磁盘，当需要访问时再换入内存。</li></ul></li></ul><h2 id="高级功能和架构" tabindex="-1"><a class="header-anchor" href="#高级功能和架构"><span>高级功能和架构</span></a></h2><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h3><ul><li><strong>Redis 主从复制的实现原理是什么？</strong><ul><li>主从复制通过主节点将数据同步到从节点。主节点将写操作记录到replication buffer中，从节点定期请求同步数据，主节点将数据发送给从节点。</li></ul></li><li><strong>Redis 主从复制的常见拓扑结构有哪些？</strong><ul><li>常见的拓扑结构包括： <ul><li><strong>单主单从</strong>：一个主节点和一个从节点。</li><li><strong>单主多从</strong>：一个主节点和多个从节点。</li><li><strong>级联复制</strong>：从节点再作为其他从节点的主节点。</li></ul></li></ul></li></ul><h3 id="集群和哨兵机制" tabindex="-1"><a class="header-anchor" href="#集群和哨兵机制"><span>集群和哨兵机制</span></a></h3><ul><li><p><strong>Redis 集群的实现原理是什么？</strong></p><ul><li>Redis集群通过分片（sharding）技术将数据分布到多个节点上。每个节点负责一部分数据，通过哈希槽（hash slot）来确定数据的归属。</li></ul></li><li><p><strong>Redis 集群会出现脑裂问题吗？</strong></p><ul><li>Redis集群通过哨兵机制和多数派选举来避免脑裂问题。只有超过半数的节点同意，才能进行主从切换。</li></ul></li><li><p><strong>在 Redis 集群中，如何根据键定位到对应的节点？</strong></p><ul><li>通过哈希槽（hash slot）来定位键。每个键通过CRC16算法计算哈希值，然后取模得到哈希槽编号，根据哈希槽编号找到对应的节点。</li></ul></li><li><p><strong>Redis 的哨兵机制是什么？</strong></p><ul><li>哨兵机制用于监控和管理Redis集群的高可用性。哨兵节点会定期检查主节点的健康状况，如果主节点宕机，哨兵会自动进行主从切换。</li></ul></li></ul><h3 id="redis事务" tabindex="-1"><a class="header-anchor" href="#redis事务"><span>Redis事务</span></a></h3><ul><li><strong>Redis 支持事务吗？如何实现？</strong><ul><li>Redis支持事务，通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>和<code>WATCH</code>命令来实现事务。</li><li><strong>MULTI</strong>：开始事务。</li><li><strong>EXEC</strong>：执行事务。</li><li><strong>DISCARD</strong>：取消事务。</li><li><strong>WATCH</strong>：监视键的变化，如果在事务执行前键被修改，事务将被取消。</li></ul></li></ul><h3 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h3><ul><li><strong>Redis 的 Lua 脚本功能是什么？如何使用？</strong><ul><li>Redis支持使用Lua脚本执行复杂的操作。通过<code>EVAL</code>命令执行Lua脚本，可以实现原子操作。</li><li>示例：<div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EVAL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;return redis.call(&#39;INCR&#39;, KEYS[1])&quot; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> counter</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="pipeline管道" tabindex="-1"><a class="header-anchor" href="#pipeline管道"><span>Pipeline管道</span></a></h3><ul><li><strong>Redis 的 Pipeline 功能是什么？</strong><ul><li>Pipeline功能允许客户端一次性发送多个命令，减少网络往返次数，提高性能。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pipelined</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(jedis </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;key1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;key2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="redis客户端" tabindex="-1"><a class="header-anchor" href="#redis客户端"><span>Redis客户端</span></a></h3><ul><li><strong>你在项目中使用的 Redis 客户端是什么？</strong><ul><li>常见的Redis客户端包括Jedis、Lettuce、Redisson等。</li><li><strong>Jedis</strong>：Java客户端，轻量级，使用广泛。</li><li><strong>Lettuce</strong>：Java客户端，支持Netty，性能较好。</li><li><strong>Redisson</strong>：Java客户端，提供了丰富的高级功能，如分布式锁。</li></ul></li></ul>`,37)]))}const p=s(t,[["render",e],["__file","redis.html.vue"]]),d=JSON.parse('{"path":"/interview/frame/redis.html","title":"Redis","lang":"en-US","frontmatter":{"order":30,"title":"Redis","description":"Redis 基础概念 Redis 是什么？ Redis（Remote Dictionary Server）是一个开源的键值存储系统，支持多种数据结构，如字符串、哈希、列表、集合和有序集合。它以其高性能和丰富的功能而著称。 数据结构 Redis 中常见的数据类型有哪些？ 常见的数据类型包括： String：字符串。 Hash：哈希表。 List：列表。 ...","head":[["meta",{"property":"og:url","content":"https://x.app/interview/frame/redis.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis 基础概念 Redis 是什么？ Redis（Remote Dictionary Server）是一个开源的键值存储系统，支持多种数据结构，如字符串、哈希、列表、集合和有序集合。它以其高性能和丰富的功能而著称。 数据结构 Redis 中常见的数据类型有哪些？ 常见的数据类型包括： String：字符串。 Hash：哈希表。 List：列表。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-28T13:29:58.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2024-11-28T13:29:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-28T13:29:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Redis 基础概念","slug":"redis-基础概念","link":"#redis-基础概念","children":[{"level":3,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[]},{"level":3,"title":"数据结构实现","slug":"数据结构实现","link":"#数据结构实现","children":[]},{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":3,"title":"持久化","slug":"持久化","link":"#持久化","children":[]},{"level":3,"title":"击穿/穿透/雪崩","slug":"击穿-穿透-雪崩","link":"#击穿-穿透-雪崩","children":[]},{"level":3,"title":"大Key和热点Key","slug":"大key和热点key","link":"#大key和热点key","children":[]},{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[]}]},{"level":2,"title":"性能及应用场景","slug":"性能及应用场景","link":"#性能及应用场景","children":[{"level":3,"title":"快/源码设计","slug":"快-源码设计","link":"#快-源码设计","children":[]},{"level":3,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[]},{"level":3,"title":"多线程和虚拟内存","slug":"多线程和虚拟内存","link":"#多线程和虚拟内存","children":[]}]},{"level":2,"title":"高级功能和架构","slug":"高级功能和架构","link":"#高级功能和架构","children":[{"level":3,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[]},{"level":3,"title":"集群和哨兵机制","slug":"集群和哨兵机制","link":"#集群和哨兵机制","children":[]},{"level":3,"title":"Redis事务","slug":"redis事务","link":"#redis事务","children":[]},{"level":3,"title":"Lua脚本","slug":"lua脚本","link":"#lua脚本","children":[]},{"level":3,"title":"Pipeline管道","slug":"pipeline管道","link":"#pipeline管道","children":[]},{"level":3,"title":"Redis客户端","slug":"redis客户端","link":"#redis客户端","children":[]}]}],"git":{"createdTime":1732800598000,"updatedTime":1732800598000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":9.76,"words":2928},"filePathRelative":"interview/frame/redis.md","localizedDate":"November 28, 2024","autoDesc":true}');export{p as comp,d as data};
