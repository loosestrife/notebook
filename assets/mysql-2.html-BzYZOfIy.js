import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as l}from"./app-CORVutdv.js";const e="/notebook/assets/image-20211110135545416-XIPgqWz-.png",h="/notebook/assets/image-20220324204029868-D0cIoTKF.png",t="/notebook/assets/image-20220324205314504-BKYhKXPI.png",p="/notebook/assets/image-20220324204347069-BY6113lV.png",k="/notebook/assets/image-20220324204721606-B_sW3L4L.png",d="/notebook/assets/image-20220324204910192-CDMl0YEi.png",r="/notebook/assets/image-20220325121029629-C0I7D1Rl.png",c="/notebook/assets/image-20220325121053355-DdvNhrFF.png",g="/notebook/assets/image-20220326090301653-D_HFtOS1.png",A="/notebook/assets/image-20220326090335787-qrNkISyC.png",y="/notebook/assets/image-20220326090348362-BbFJ8Mqc.png",o={};function B(m,i){return l(),a("div",null,i[0]||(i[0]=[n('<h2 id="一-mysql索引" tabindex="-1"><a class="header-anchor" href="#一-mysql索引"><span>一 MySQL索引</span></a></h2><p>索引是一种可以高效获取数据的数据结构、索引可以提高查询的速度。</p><p>默认使用主键列作为索引（若不设置主键、mysql会自动设置一个隐藏列作为索引）</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener noreferrer">CodingLabs - MySQL索引背后的数据结构及算法原理</a></p><br><h3 id="_1-为什么使用索引" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用索引"><span>1. 为什么使用索引</span></a></h3><p>在海量数据中进行查询某条记录的情景中，如何提升查询性能跟要查询的数据字段是否有索引有关系</p><ul><li><p>没有使用索引的时候，数据的查询需要进行多次IO读写（全表扫描的过程），性能较差</p></li><li><p>如果字段加了索引（相当于加了个目录），那么查询的性能就非常快!</p></li></ul><img src="'+e+`" alt="image-20211110135545416" style="zoom:67%;"><br><h3 id="_2-索引的存储位置" tabindex="-1"><a class="header-anchor" href="#_2-索引的存储位置"><span>2. 索引的存储位置</span></a></h3><p>数据和索引的存储位置：</p><p>对于mac系统默认在 <code>/usr/local/mysql</code> 文件夹中，对于win系统默认在：<code>c:/programdata/mysql</code> (隐藏文件夹).</p><p>不在默认位置的情况下，一般是安装时初始化MySQL自定义了数据文件的存放位置，比如修改为安装目录的 data 目录下</p><br><p>存储文件的详细说明：</p><ul><li>InnoDB存储引擎的表∶将索引和数据存放在同一个文件里。<code> *.ibd</code></li><li>MyISAM存储引擎的表:索引和数据分开两个文件来存储。索引: <code> *.MYI</code> ; 数据: <code>.MYD</code></li></ul><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">【注意】</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">使用InnoDB存储引擎的创建的表会生成两个文件：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.frm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 结尾的表结构定义文件，</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放数据和索引的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.ibd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">而使用MyISAM存储引擎的创建的表会生成三个文件：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.frm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 结尾的表结构定义文件，</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放数据的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.myd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放索引的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.myi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_3-索引的分类和创建" tabindex="-1"><a class="header-anchor" href="#_3-索引的分类和创建"><span>3. 索引的分类和创建</span></a></h3><ul><li><p>主键索引:主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的</p><br></li><li><p>普通索引:为普通列创建的索引。创建索引的命令∶</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名(列名) </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><br></li><li><p>唯一索引∶就像是唯一列，列中的数据是唯一的。比普通索引的性能要好</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unique index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名(列名)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unique index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_unique_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><br></li><li><p>联合索引(组合索引)∶一次性为表中的多个字段一起创建索引。注意:一个联合索引建议不要超过5个列</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表(列1,列2,列3, ...)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name_age_position</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, age, position);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><br></li><li><p>全文索引：进行查询的时候，数据源可能来自于不同的字段或者不同的表。MyISAM存储引擎支持全文索引</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">注意：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">在实际生产环境中，并不会使用MySQL提供的MyISAM存储引擎的全文索引功能来是实现全文查找。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">而是会使用第三方的搜索引擎中间件比如</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ElasticSearch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">推荐</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">、</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Solr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 等。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><br><p>创建索引的三种方式：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第一种方式：在执行create table时创建索引 </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> user_index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> auto_increment </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">primary key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    first_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    last_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id_card </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">18</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    information </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">225</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    key</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(first_name,last_name),     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引 （索引名为第一列的列名）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unique</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(id_card),                </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 唯一索引 （只有一列时索引名与列名一致）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fulltext</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(information)           </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 全文索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    -- 还可以用如下方式：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_first_name(first_name) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> btree </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第二种方式：使用Alter table命令去增加索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  index_name(column_list);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第三种方式：使用create index命令来创建</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> index_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name(column_list);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 删除索引的方式：根据索引名来删除普通索引、唯一索引、全文索引。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名  </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">drop</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 索引名</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查看表的全部索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">index</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_4-最左前缀原则" tabindex="-1"><a class="header-anchor" href="#_4-最左前缀原则"><span>4. 最左前缀原则</span></a></h3><p>mysql的引擎在查询时为了更好的利用索引，再查询过程中会动态调整查询字段顺序以便利用索引</p><br><h2 id="二-索引数据结构" tabindex="-1"><a class="header-anchor" href="#二-索引数据结构"><span>二 索引数据结构</span></a></h2><p>使用索引查找数据性能很快，避免了全表扫描的多次磁盘IO读写。</p><p>但是使用索引实际上也需要在索引中查找数据，而且数据数量级是一样的，那么为什么索引就更快呢?</p><p>这就要探究索引使用的数据结构了</p><br><p>而我们去考察索引应该采用哪种数据结构，那么主要是考察两个方面</p><ol><li>这种数据结构能不能帮助我们提高查询单个值的效率</li><li>这种数据结构能不能帮助我们提高查询范围值的效率</li></ol><br><h3 id="_1-数组和链表" tabindex="-1"><a class="header-anchor" href="#_1-数组和链表"><span>1. 数组和链表</span></a></h3><figure><img src="`+h+'" alt="image-20220324204029868" tabindex="0" loading="lazy"><figcaption>image-20220324204029868</figcaption></figure><br><h2 id="_2-hash表" tabindex="-1"><a class="header-anchor" href="#_2-hash表"><span>2. hash表</span></a></h2><figure><img src="'+t+'" alt="image-20220324205314504" tabindex="0" loading="lazy"><figcaption>image-20220324205314504</figcaption></figure><br><h3 id="_3-二叉树" tabindex="-1"><a class="header-anchor" href="#_3-二叉树"><span>3. 二叉树</span></a></h3><figure><img src="'+p+'" alt="image-20220324204347069" tabindex="0" loading="lazy"><figcaption>image-20220324204347069</figcaption></figure><ul><li>可以适当的帮助我们提高查询单个值的效率</li><li>可以适当的帮助我们提高查询范围值的效率</li></ul><p>二叉树（包括AVL树、红黑树）对于提升查询效率的帮助是十分有限的。为什么呢？</p><p>因为这些树只有两个“叉”，当数据变多的时候，树的层高会急剧上升，这就会导致搜索的困难增加，效率会明显降低。</p><br><h3 id="_4-b树和b-树" tabindex="-1"><a class="header-anchor" href="#_4-b树和b-树"><span>4. B树和B+树</span></a></h3><figure><img src="'+k+'" alt="image-20220324204721606" tabindex="0" loading="lazy"><figcaption>image-20220324204721606</figcaption></figure><br><figure><img src="'+d+'" alt="image-20220324204910192" tabindex="0" loading="lazy"><figcaption>image-20220324204910192</figcaption></figure><br><h2 id="三-b-树的索引" tabindex="-1"><a class="header-anchor" href="#三-b-树的索引"><span>三 B+树的索引</span></a></h2><p>在数据库中，B+树的高度一般都在2～4层，这也就是说查找某一键值的行记录时最多只需要2到4次IO</p><br><p>数据库中的B+树索引可以分为聚集索引（clustered inex）和 非聚集索引（secondary index，辅助索引），</p><p>但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。</p><p>聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p><br><h2 id="_1-聚集索引" tabindex="-1"><a class="header-anchor" href="#_1-聚集索引"><span>1. 聚集索引</span></a></h2><p>聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p><br><p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。</p><p>在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。</p><p>此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。</p><br><p>许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。</p><p>但是试想一下，如果聚集索引必须按照特定顺序存放物理记录，则维护成本显得非常之高。</p><p>所以，聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：</p><p>一是前面说过的页通过双向链表链接，页按照主键的顺序排序；</p><p>另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p><p>聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。</p><h3 id="_2-非聚集索引" tabindex="-1"><a class="header-anchor" href="#_2-非聚集索引"><span>2. 非聚集索引</span></a></h3><p>辅助索引（Secondary Index），也称非聚集索引（non-clustered index），其叶子节点并不包含行记录的全部数据。</p><p>叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）</p><br><h3 id="_3-innodb索引" tabindex="-1"><a class="header-anchor" href="#_3-innodb索引"><span>3. InnoDB索引</span></a></h3><br><figure><img src="'+r+'" alt="image-20220325121029629" tabindex="0" loading="lazy"><figcaption>image-20220325121029629</figcaption></figure><br><h3 id="_4-myisam索引" tabindex="-1"><a class="header-anchor" href="#_4-myisam索引"><span>4. MyISAM索引</span></a></h3><figure><img src="'+c+`" alt="image-20220325121053355" tabindex="0" loading="lazy"><figcaption>image-20220325121053355</figcaption></figure><br><h2 id="四-索引常见问题" tabindex="-1"><a class="header-anchor" href="#四-索引常见问题"><span>四 索引常见问题</span></a></h2><h3 id="_1-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-数据结构"><span>1. 数据结构</span></a></h3><p>索引采用的是什么数据结构？为什么采用这种数据结构</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">B+树（hash表）。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">B+树对比B树的好处（优化）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- B+树在叶子节点之间维护了一个指针，指向下一个叶子节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- 非叶子节点在叶子节点冗余</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- 非叶子节点只存储key，不存储data</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_2-自增主键" tabindex="-1"><a class="header-anchor" href="#_2-自增主键"><span>2. 自增主键</span></a></h3><p>数据库为什么定义主键，并且在MySQL中使用推荐使用主键自增的策略？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">为什么要自定义主键：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">因为假如不自定义主键，那么在InnoDB中，也会维护一个隐藏的列来当做主键，这样就丢失了主键索引树的性能。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">为什么要使用主键自增的策略呢？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">因为在插入的过程中，需要经过 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`分类、提取\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (树的旋转) 等步骤，如果使用主键自增的策略，那么永远只会影响到索引树右边的结构，这样对整个B+树的结构影响是有限的，可以提高插入的效率</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_3-innodb和myisam" tabindex="-1"><a class="header-anchor" href="#_3-innodb和myisam"><span>3. InnoDB和MyISAM</span></a></h3><p>InnoDB和MyISAM有什么区别？什么情况下使用MyISAM？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 支持事务，MyISAM不支持事务，对于 InnoDB，每条SQL语句都自动封装成事务，自动提交，影响速度 </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 支持外键，MyISAM不支持外键 </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 的主键索引是聚集索引，数据文件和索引存储在一起。MyISAM则全是非聚集索引，索引和数据文件是分离的</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   InnoDB 的存储文件是 frm 和 ibd，而MyISAM是 frm、myd、myi 三个文件。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 不保存表的行数，</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`查询某张表的行数\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">时会全表扫描。MyISAM会保存整个表的行数，执行速度很快 </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 支持表锁和行锁（默认），而 MyISAM支持表锁。 </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   行锁是指：锁的对象是一行数据、 表锁是指：锁的对象是一整张表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   行锁的效率比表锁的效率要高。锁的粒度越细，锁的效率越高。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. InnoDB 表必须要有一个主键（如果用户不设置，那么引擎会自行设定一列</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[隐藏列]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">当做主键），MyISAM 则可以没有 </span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">如何选择存储引擎？ </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">是否需要事务？如果不需要（如历史记录数据），则可以使用MyISAM </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">绝大多数操作是否是查询？如果是，可以选择MyISAM，有读也有写，则选择 InnoDB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_4-什么是回表" tabindex="-1"><a class="header-anchor" href="#_4-什么是回表"><span>4. 什么是回表？</span></a></h3><p>什么是回表？如何避免回表？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">查询多次索引树（非聚集索引），并且最后需要返回到主键索引树查询的情况，叫做回表。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">一般而言根据非聚集索引查询数据时，都会再次到主键索引树查询一次（除非查询结果只包含索引列和主键）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">如何避免回表呢？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- 应该尽量避免写 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`select *\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- 在适当的列建立索引</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- 可以考虑使用联合索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  联合索引：针对多列值来构建B+树。（若查询的所有列是一个联合索引，则使用非聚集索引一次就可以查询到数据）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  也可以称这种方式为：覆盖索引 （即将被查询的字段建立到联合索引中）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="_5-索引越多越好" tabindex="-1"><a class="header-anchor" href="#_5-索引越多越好"><span>5. 索引越多越好？</span></a></h3><p>索引性能这么好，是不是一个表建立的索引越多越好？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">不是。一个表中的索引建立多了会影响增删改的性能。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">在企业中，对于单表来说，建立几个索引是合适的呢？不同的企业可能有不同的规范，一般默认不超过五个。即默认声明的索引列不超过五列。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. innodb 默认页大小</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. 非聚集索引中、非唯一列的 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 只包含当前列信息吗？ </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">根据 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`show index from table_name;\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 的查询结果来看确实如此，那这个索引列有多个重复值时，是如何存储的呢？</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">我原本的猜测是叶子结点存储了多个相关的主键信息</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">但有的书中有这样的描述：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    对于二级非唯一索引而言，因为只有索引列本身再加上主键列才能保证索引记录是唯一的，</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    所以这二者合起来才能构成我们所说的“键”，而“值”就为空了，</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    也就是说，二级非唯一索引中，在记录构成方面，非叶子节点只是比叶子节点多了一个PageNo指针信息。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">也就是说 主键 + 这个索引列 一起构成了 索引树中的 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ？....</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. innodb中为什么要采用 聚集索引 ，这样导致回表时的性能消耗（虽然能通过联合索引避免回表、但这样做本身也需要权衡相关查询语句的使用频率和索引带来影响）和MyISAM中（单独存储数据）必然进行一次IO的消耗相比，差距大吗？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">有相关解释是说MyISAM中的这种方式必然会进行一次IO, 是这样吗？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复杂点的情形下，当非聚集索引命中多条记录时：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	Innodb：可能导致回表，会根据主键进行多次聚集索引查询</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	MyISAM: 多次的随机IO?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">innodb这样的策略是在 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`可能导致回表\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 和 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`必然进行IO 之中的选择吗？</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+g+'" alt="image-20220326090301653" tabindex="0" loading="lazy"><figcaption>image-20220326090301653</figcaption></figure><figure><img src="'+A+'" alt="image-20220326090335787" tabindex="0" loading="lazy"><figcaption>image-20220326090335787</figcaption></figure><figure><img src="'+y+`" alt="image-20220326090348362" tabindex="0" loading="lazy"><figcaption>image-20220326090348362</figcaption></figure><br><h1 id="五-数据库查询优化" tabindex="-1"><a class="header-anchor" href="#五-数据库查询优化"><span>五 数据库查询优化</span></a></h1><ul><li><p>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p></li><li><p>应避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫 描，</p><p>如： select id from t where num is null 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库</p><p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p></li><li><p>应避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描。 -</p></li><li><p>应避免在 where 子句中使用or来连接条件，如果一个字段有索引,一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 如：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> or</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> Name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 可以这样查询：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">union all</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> Name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于连续的数值，能用 between 就不要用 in 了：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">between</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>很多时候用 exists 代替 in 是一个好的选择</p></li></ul>`,113)]))}const u=s(o,[["render",B],["__file","mysql-2.html.vue"]]),F=JSON.parse('{"path":"/tool/db/mysql-2.html","title":"MySQL调优","lang":"en-US","frontmatter":{"order":15,"title":"MySQL调优","description":"一 MySQL索引 索引是一种可以高效获取数据的数据结构、索引可以提高查询的速度。 默认使用主键列作为索引（若不设置主键、mysql会自动设置一个隐藏列作为索引） CodingLabs - MySQL索引背后的数据结构及算法原理 1. 为什么使用索引 在海量数据中进行查询某条记录的情景中，如何提升查询性能跟要查询的数据字段是否有索引有关系 没有使用索引...","head":[["meta",{"property":"og:url","content":"https://x.app/notebook/tool/db/mysql-2.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"MySQL调优"}],["meta",{"property":"og:description","content":"一 MySQL索引 索引是一种可以高效获取数据的数据结构、索引可以提高查询的速度。 默认使用主键列作为索引（若不设置主键、mysql会自动设置一个隐藏列作为索引） CodingLabs - MySQL索引背后的数据结构及算法原理 1. 为什么使用索引 在海量数据中进行查询某条记录的情景中，如何提升查询性能跟要查询的数据字段是否有索引有关系 没有使用索引..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-02T17:12:36.000Z"}],["meta",{"property":"article:author","content":"Mr.Topple"}],["meta",{"property":"article:modified_time","content":"2024-06-02T17:12:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL调优\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-02T17:12:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Topple\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"一 MySQL索引","slug":"一-mysql索引","link":"#一-mysql索引","children":[{"level":3,"title":"1. 为什么使用索引","slug":"_1-为什么使用索引","link":"#_1-为什么使用索引","children":[]},{"level":3,"title":"2. 索引的存储位置","slug":"_2-索引的存储位置","link":"#_2-索引的存储位置","children":[]},{"level":3,"title":"3. 索引的分类和创建","slug":"_3-索引的分类和创建","link":"#_3-索引的分类和创建","children":[]},{"level":3,"title":"4. 最左前缀原则","slug":"_4-最左前缀原则","link":"#_4-最左前缀原则","children":[]}]},{"level":2,"title":"二 索引数据结构","slug":"二-索引数据结构","link":"#二-索引数据结构","children":[{"level":3,"title":"1. 数组和链表","slug":"_1-数组和链表","link":"#_1-数组和链表","children":[]}]},{"level":2,"title":"2. hash表","slug":"_2-hash表","link":"#_2-hash表","children":[{"level":3,"title":"3. 二叉树","slug":"_3-二叉树","link":"#_3-二叉树","children":[]},{"level":3,"title":"4. B树和B+树","slug":"_4-b树和b-树","link":"#_4-b树和b-树","children":[]}]},{"level":2,"title":"三 B+树的索引","slug":"三-b-树的索引","link":"#三-b-树的索引","children":[]},{"level":2,"title":"1. 聚集索引","slug":"_1-聚集索引","link":"#_1-聚集索引","children":[{"level":3,"title":"2. 非聚集索引","slug":"_2-非聚集索引","link":"#_2-非聚集索引","children":[]},{"level":3,"title":"3. InnoDB索引","slug":"_3-innodb索引","link":"#_3-innodb索引","children":[]},{"level":3,"title":"4. MyISAM索引","slug":"_4-myisam索引","link":"#_4-myisam索引","children":[]}]},{"level":2,"title":"四 索引常见问题","slug":"四-索引常见问题","link":"#四-索引常见问题","children":[{"level":3,"title":"1. 数据结构","slug":"_1-数据结构","link":"#_1-数据结构","children":[]},{"level":3,"title":"2. 自增主键","slug":"_2-自增主键","link":"#_2-自增主键","children":[]},{"level":3,"title":"3. InnoDB和MyISAM","slug":"_3-innodb和myisam","link":"#_3-innodb和myisam","children":[]},{"level":3,"title":"4. 什么是回表？","slug":"_4-什么是回表","link":"#_4-什么是回表","children":[]},{"level":3,"title":"5. 索引越多越好？","slug":"_5-索引越多越好","link":"#_5-索引越多越好","children":[]}]}],"git":{"createdTime":1717348356000,"updatedTime":1717348356000,"contributors":[{"name":"Neil","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":12.67,"words":3802},"filePathRelative":"tool/db/mysql-2.md","localizedDate":"June 2, 2024","autoDesc":true}');export{u as comp,F as data};
