import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as i,d as l,e,b as s,w as n,r as d,o as c}from"./app-BE26t00W.js";const p={},h={start:"5"};function g(v,a){const t=d("RouteLink");return c(),r("div",null,[a[8]||(a[8]=i('<h2 id="java基础知识" tabindex="-1"><a class="header-anchor" href="#java基础知识"><span>Java基础知识</span></a></h2><ol><li>你认为 Java 的优势是什么？</li></ol><p>在过去Java因其 <strong>跨平台，垃圾回收，面向对象</strong> 等特点而流行起来，到现在形成了 <mark>成熟的生态</mark> ，拥有完善的工具，框架和中间件，以及大量的专业人才，我觉得这才是Java现如今最大的优势和竞争力。</p><ol start="2"><li>JDK 和 JRE 有什么区别？你使用过哪些 JDK 提供的工具？</li></ol><p>JRE指的是Java运行环境，包含了 <strong>JVM</strong> 及 <strong>核心类库</strong> ，JDK可视为JRE的超集，它包含了JRE 以及其他用于开发和调试的工具</p><details class="hint-container details"><summary>JDK提供的主要工具</summary><ul><li>JDK 常见工具 <ul><li>javac:Java 编译器，负责将 Java 源代码编译成字节码(.class 文件)。</li><li>java:运行 Java 应用程序的命令，使用 JM 来解释并执行编译后的字节码文件。</li><li>javadoc:生成 API文档的工具，能够根据源代码中的注释生成 HTML 格式的文档。</li><li>jar:用于创建和管理 JAR 文件的工具，可以将多个.class 文件打包为单一文件，便于分发和管理</li><li>jdb:Java 调试工具，用于在命令行中调试 Java 应用程序，支持断点设置、变量查看等功能。</li></ul></li><li>性能监控和分析工具 <ul><li>jps:Java 进程工具，显示所有正在运行的 Java 进程，便于监控和诊</li><li><mark>jstack</mark>:生成线程堆栈信息的工具，常用于<strong>分析死锁和线程问题</strong>。</li><li><mark>jmap</mark>:内存映射工具，可以生成堆转储(heap dump)文件，便于<strong>内存泄漏分析和垃圾回收优化</strong>。</li><li><mark>jhat</mark>:堆分析工具，配合 jmap 使用，分析生成的堆转储文件，帮助开发者了解内存使用情况。</li><li>jstat:JVM 统计监控工具，实时监控垃圾回收、内存、类加载等信息，帮助开发者调优 JM 性能。</li><li>jconsole:图形化的 JM 监控工具，可以监控应用程序的内存、线程和类加载情况，常用于监控和调试。</li><li>jvisualvm:功能强大的性能分析工具，支持堆、线程、GC的详细监控，还提供内存分析和 CPU 性能分析。</li></ul></li><li>诊断工具 <ul><li>jinfo:用于查看和修改正在运行的 JVM 参数，便于动态调优和调整 JM 行为,</li><li>jstatd:远程 JVM 监控工具，可以通过网络远程监控 JVM 的状态，适合分布式系统中的性能监控。</li></ul></li></ul></details><h3 id="java数据类型" tabindex="-1"><a class="header-anchor" href="#java数据类型"><span>Java数据类型</span></a></h3><ol><li>Java 中的基本数据类型有哪些？</li></ol><p>8种基本数据类型: 整型（byte,short,int,long）, 浮点型(float,double), 字符型(char), 布尔型(boolean)</p>',9)),l("p",null,[a[1]||(a[1]=e("更多更详细的内容参照：")),s(t,{to:"/java/syntax/base/Java%E5%9F%BA%E7%A1%80.html#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"},{default:n(()=>a[0]||(a[0]=[e("Java基本数据类型")])),_:1})]),a[9]||(a[9]=i('<ol start="2"><li>Java 中包装类型和基本类型的区别是什么？</li></ol><p><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code></p><p>包装类型的本质是对象，适用于需要对象特性、支持 <code>null</code> 值、需要调用方法的场景</p><ol start="3"><li>什么是 Java 中的自动装箱和拆箱？</li></ol><ul><li><p>自动装箱（Autoboxing）: 将基本类型自动转换为其对应的包装类型的过程。<br> 当遇到将基本类型赋值给包装类型的情况时，编译器会自动调用 <code>Integer.valueOf(int)</code></p></li><li><p>拆箱（Unboxing）: 将包装类型自动转换为其对应的基本类型的过程。<br> 当编译器遇到将包装类型赋值给基本类型的情况时，会自动插入相应的解包方法调用。如：<code>Integer.intValue()</code></p></li></ul><ol start="4"><li>什么是 Java 的 Integer 缓存池？</li></ol><p><code>Integer</code> 类的内部实现中使用了一个静态数组来存储这些常用的小整数值(-128 到 127)，以减少对象的创建和垃圾回收的开销。</p><p><strong>注意事项</strong>：使用 <code>==</code> 比较 <code>Integer</code> 对象时需要注意缓存范围的影响，推荐使用 <code>equals</code> 方法进行值比较。</p>',8)),l("ol",h,[l("li",null,[a[3]||(a[3]=e("什么是 Java 的 BigDecimal？ 参照：")),s(t,{to:"/java/syntax/base/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93.html#_2-bigdecimal"},{default:n(()=>a[2]||(a[2]=[e("BigDecimal")])),_:1})])]),a[10]||(a[10]=i(`<p><code>BigDecimal</code>是Java中用于进行高精度浮点数运算的工具类，适用于金融和科学计算等需要高精度的场景。</p><div class="hint-container warning"><p class="hint-container-title">BigDecimal</p><p>BigDecimal是不可变类，所有的算术运算都会返回新的BigDecimal对象（安全但性能较差）</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bd1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;123.456&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 使用字符串初始化，推荐     </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bd2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">123L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 也可以使用静态方法 valueOf</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bd3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">123.456</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 使用double初始化，可能丢失精度</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>常用算数方法：<code>add</code>, <code>subtract</code>, <code>multiply</code>, <code>divide</code></li><li>数值比较：<code>int res = bd3.compareTo(bd4)</code></li><li>转换为字符串： <ul><li><code>toString()</code> --可能会是科学记数法</li><li><code>toPlainString()</code> --始终提供完整的十进制字符串表示</li></ul></li></ul></div><h3 id="java字符串对象" tabindex="-1"><a class="header-anchor" href="#java字符串对象"><span>Java字符串对象</span></a></h3>`,3)),l("p",null,[a[5]||(a[5]=e("Java中处理字符串的主要类是String、StringBuilder和StringBuffer。 参考：")),s(t,{to:"/java/syntax/base/%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E4%B8%89-%E5%AD%97%E7%AC%A6%E4%B8%B2-string"},{default:n(()=>a[4]||(a[4]=[e("Java字符串")])),_:1})]),a[11]||(a[11]=i('<div class="hint-container info"><p class="hint-container-title">String面试题</p><h4 id="使用-new-string-abc-语句在-java-中会创建多少个对象" tabindex="-1"><a class="header-anchor" href="#使用-new-string-abc-语句在-java-中会创建多少个对象"><span>使用 new String(&quot;abc&quot;) 语句在 Java 中会创建多少个对象？</span></a></h4><p>会创建1-2两个字符串，使用new关键字时，如果字符串常量池中不存在当前字符串，那就会在堆上创建两个字符串对象，其中一个会被保存到字符串常量池中。</p><p>如果字符串常量池中已经存在该字符串的引用，则只会在堆中创建一个</p><h4 id="为什么-jdk-9-中将-string-的-char-数组改为-byte-数组" tabindex="-1"><a class="header-anchor" href="#为什么-jdk-9-中将-string-的-char-数组改为-byte-数组"><span>为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？</span></a></h4><p>为了节省内存空间，提升内存利用率。</p><ul><li>JDK9之前String是基于char[] 实现的，内部采用UTF-16编码，每个字符占用两字节。</li><li>JDK9中String采用byte[]数组来实现，并使用coder变量标识编码方式(UTF-16/Latin-1)， 当字符仅需一个字符的空间时，就可以减少内存占用</li></ul></div><p>Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？</p><ul><li>String: 不可变，适合少量字符串操作。<br> String的本质就是一个不可变的字符数组： <code>private final char value[];</code></li><li>StringBuilder: 可变，但非线程安全，适合单线程环境中的高性能字符串处理</li><li>StringBuffer：可变，且线程安全，适合多线程环境中频繁修改字符串的场景</li></ul><div class="hint-container info"><p class="hint-container-title">Java 中的序列化和反序列化</p><ul><li>序列化: 将对象的状态信息转换为可以存储或传输的形式，要使一个对象可以被序列化，该对象的类必须实现 <code>Serializable</code> 接口。</li><li>反序列化: 将字节流恢复为对象的过程</li></ul><p>建议显式定义 <code>serialVersionUID</code>，以避免因类结构变化而导致的序列化失败。</p></div><p>为什么在 Java 中编写代码时会遇到乱码问题？</p><p>乱码是因为<strong>编解码时使用的字符集不一致</strong>导致的。</p><h3 id="java面向对象" tabindex="-1"><a class="header-anchor" href="#java面向对象"><span>Java面向对象</span></a></h3><p>Java 面向对象编程与面向过程编程的区别是什么？</p><ul><li><p><strong>面向对象编程</strong>：关注数据（对象）及其行为（方法），通过类和对象来组织代码。数据和操作数据的方法封装在一起，外部访问受限，增强数据安全性。支持继承和多态，可以通过继承扩展类的功能，多态允许子类方法覆盖父类方法。<strong>面向对象更符合人类的思维方式</strong>。</p></li><li><p><strong>面向过程编程</strong>：关注过程（函数）和数据，通过函数和数据结构来组织代码。数据和函数分离，数据暴露在外，容易被随意修改。</p></li></ul><div class="hint-container info"><p class="hint-container-title">封装继承多态</p><h4 id="什么是-java-的封装特性" tabindex="-1"><a class="header-anchor" href="#什么是-java-的封装特性"><span>什么是 Java 的封装特性？</span></a></h4><p>指将对象的 状态和行为（数据和方法）封装在内部，通过公开的接口与外部进行交互。封装的主要目的是隐藏内部的实现细节，只暴露必要的功能。且修改内部的具体实现外部也无法感知到 （数据保护，代码复用）</p><h4 id="什么是-java-中的继承机制-为什么-java-不支持多重继承" tabindex="-1"><a class="header-anchor" href="#什么是-java-中的继承机制-为什么-java-不支持多重继承"><span>什么是 Java 中的继承机制？为什么 Java 不支持多重继承？</span></a></h4><ul><li><p>子类继承父类的属性和方法，使得类之间形成层次结构，不仅代码得到重用，还可以进行扩展。继承是实现 多态，抽象和代码复用的关键。</p></li><li><p>多继承会产生菱形继承问题，例如：BC继承了A，D又继承了BC，假设D现在要调用A中的方法，但是B C都有不同的实现，此时就会出现歧义。</p></li></ul><p>既然多继承不行，为什么接口多实现可以？</p><p>Java8之前，接口是无法定义具体的方法实现的，必须由子类自己实现，并不会产生歧义。</p><p>Java8有了默认方法，但是强制规定如果多个接口内有相同的默认方法，子类必须重写该方法。</p><h4 id="什么是-java-的多态特性" tabindex="-1"><a class="header-anchor" href="#什么是-java-的多态特性"><span>什么是 Java 的多态特性？</span></a></h4><p>指同一个接口或者父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法。</p><p>它允许同一方法在不同的对象上表现出不同的行为。通过多态，程序可以灵活的处理不同类型的对象，降低代码耦合度。</p></div><p>Java 中的访问修饰符有哪些？</p><table><thead><tr><th>访问修饰符</th><th>访问范围</th><th>示例</th></tr></thead><tbody><tr><td><strong>private</strong></td><td>仅限于同一个类内部</td><td><code>private int privateVar;</code></td></tr><tr><td><strong>default</strong></td><td>同一个包内的类</td><td><code>int defaultVar;</code></td></tr><tr><td><strong>protected</strong></td><td>同一个包内的类以及不同包中的子类</td><td><code>protected int protectedVar;</code></td></tr><tr><td><strong>public</strong></td><td>所有类，不受包的限制</td><td><code>public int publicVar;</code></td></tr></tbody></table><h3 id="方法和参数传递" tabindex="-1"><a class="header-anchor" href="#方法和参数传递"><span>方法和参数传递</span></a></h3><ol><li>Java 中静态方法和实例方法的区别是什么？</li></ol><ul><li><strong>静态方法</strong>：属于类，通过类名调用，只能访问静态成员，不能被重写。</li><li><strong>实例方法</strong>：属于对象，通过对象调用，可以访问所有成员，可以被重写。</li></ul><ol start="2"><li>Java 方法重载和方法重写之间的区别是什么？</li></ol><ul><li><strong>方法重载</strong>：在同一类中，方法名相同但参数列表不同，可以在编译时根据参数类型和数量区分方法</li><li><strong>方法重写</strong>：在子类中，方法名、返回类型和参数列表都相同，用于实现多态，改变父类方法的行为</li></ul><ol start="3"><li>Java 中的参数传递是按值还是按引用？</li></ol><div class="hint-container tip"><p class="hint-container-title">值传递（pass by value）和引用传递（pass by reference）</p><p>在Java中，无论是基本类型还是引用类型的数据，参数传递都只有 <strong>值传递（pass by value）</strong></p><ul><li>传递基本类型的参数时，传递的是值的副本。不会影响到原本的值。</li><li>传递引用数据类型时，传递的是引用的副本，使得方法参数和原本的变量均指向同一对象，因此可以修改对象的属性，但是无法让原本的变量指向其他对象。</li></ul></div>',19)),l("p",null,[a[7]||(a[7]=e("更详细的内容参照：")),s(t,{to:"/java/syntax/base/Java%E5%9F%BA%E7%A1%80.html#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"},{default:n(()=>a[6]||(a[6]=[e("Java参数传递")])),_:1})]),a[12]||(a[12]=i('<h3 id="接口和抽象类" tabindex="-1"><a class="header-anchor" href="#接口和抽象类"><span>接口和抽象类</span></a></h3><p>接口和抽象类有什么区别？</p><div class="hint-container info"><p class="hint-container-title">抽象类和接口</p><h4 id="普通类和抽象类有什么区别" tabindex="-1"><a class="header-anchor" href="#普通类和抽象类有什么区别"><span>普通类和抽象类有什么区别？</span></a></h4><ul><li><strong>普通类</strong>：可以直接实例化，提供具体的方法实现。</li><li><strong>抽象类</strong>：不能直接实例化，可以包含抽象方法（没有具体实现的方法），子类必须实现这些抽象方法。</li></ul><h4 id="抽象类和接口有什么区别" tabindex="-1"><a class="header-anchor" href="#抽象类和接口有什么区别"><span>抽象类和接口有什么区别？</span></a></h4><ul><li><strong>抽象类</strong>： 可以包含抽象方法和具体方法。 只能单继承。可以包含成员变量。</li><li><strong>接口</strong>： 只能包含抽象方法（Java 8 以后可以包含默认方法和静态方法）。 可以多实现。 成员变量默认是 <code>public static final</code>。</li></ul></div><h3 id="深浅拷贝" tabindex="-1"><a class="header-anchor" href="#深浅拷贝"><span>深浅拷贝</span></a></h3><p>Java 中的深拷贝和浅拷贝有什么区别？</p><ul><li><strong>浅拷贝</strong>：创建一个新对象，但只复制基本数据类型和引用类型的数据地址，原始对象和拷贝对象共享引用类型的内存地址。</li><li><strong>深拷贝</strong>：创建一个完全独立的新对象，复制所有数据，包括引用类型的数据，使得原始对象和拷贝对象互不影响。</li></ul><h3 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h3><p>什么是 Java 内部类？它有什么作用？</p><p><strong>定义</strong>：内部类是指在一个类的内部定义的类。</p><ol><li><strong>成员内部类（Member Inner Class）</strong>：定义在类的内部，但不在方法或代码块中。可以访问外部类的所有成员（包括私有成员）。</li><li><strong>局部内部类（Local Inner Class）</strong>： 定义在方法或代码块中。 只能在定义它的方法或代码块中使用。</li><li><strong>匿名内部类（Anonymous Inner Class）</strong>： 没有名字，通常用于创建单个对象。 经常用于事件监听器等场景。</li><li><strong>静态内部类（Static Nested Class）</strong>： 使用 <code>static</code> 关键字修饰。 不依赖于外部类的实例，可以直接通过外部类名访问。</li></ol><p>作用</p><ol><li><strong>逻辑封装</strong>：内部类可以访问外部类的私有成员，实现更紧密的封装。</li><li><strong>代码组织</strong>： 内部类可以将相关的类组织在一起，提高代码的可读性和可维护性。</li><li><strong>事件处理</strong>： 匿名内部类常用于事件监听器，简化事件处理代码。</li></ol><h3 id="object类中的方法" tabindex="-1"><a class="header-anchor" href="#object类中的方法"><span>Object类中的方法</span></a></h3><p>Java Object 类中有什么方法，有什么作用？</p><ol><li><p><strong><code>toString()</code></strong>：返回对象的字符串表示形式。默认返回对象的类名和哈希码</p></li><li><p><strong><code>hashCode()</code></strong>：基于对象的内存地址生成哈希码。</p></li><li><p><strong><code>equals(Object obj)</code></strong>：检查两个对象是否是同一个对象（即引用是否相同）。</p></li><li><p><strong><code>clone()</code></strong>：创建并返回对象的一个副本。默认是浅拷贝，需要实现 <code>Cloneable</code> 接口。通常会重写实现深拷贝</p></li><li><p><strong><code>finalize()</code></strong>：对象被垃圾回收前调用的方法。用于释放资源，但不建议依赖此方法进行资源管理，应使用 <code>try-with-resources</code> 等更可靠的机制。</p></li><li><p><strong><code>getClass()</code></strong>：返回对象的 <code>Class</code> 对象。</p></li><li><p><strong><code>wait()</code></strong>、<strong><code>notify()</code></strong>、<strong><code>notifyAll()</code></strong>：用于多线程编程中的同步控制。</p><ul><li><strong><code>wait()</code></strong>：使当前线程等待，释放对象锁。</li><li><strong><code>notify()</code></strong>：唤醒一个等待该对象锁的线程。</li><li><strong><code>notifyAll()</code></strong>：唤醒所有等待该对象锁的线程。</li></ul></li></ol><h3 id="equals-hashcode" tabindex="-1"><a class="header-anchor" href="#equals-hashcode"><span>equals/hashCode</span></a></h3><p>Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？</p><ul><li><strong><code>hashCode</code> 方法</strong>：返回对象的哈希码，用于哈希表中的快速查找。</li><li><strong><code>equals</code> 方法</strong>：判断两个对象是否相等，通常需要重写以实现自定义的相等逻辑。</li><li><strong><code>==</code> 操作符</strong>：比较两个对象的引用是否相同，即是否指向同一个对象。</li></ul><p>Java 中的 hashCode 和 equals 方法之间有什么关系？</p><ul><li><strong>一致性</strong>：如果两个对象通过 <code>equals</code> 方法判断为相等，那么它们的 <code>hashCode</code> 方法返回的值必须相同。(这样可以确保在哈希表中，相等的对象会被放在同一个桶中)</li><li><strong>反向关系</strong>：如果两个对象的 <code>hashCode</code> 值不同，那么它们一定不相等。</li></ul><p>在哈希表（如 <code>HashMap</code>、<code>HashSet</code>）中，<code>hashCode</code> 用于快速定位桶的位置</p><h3 id="io和网络编程" tabindex="-1"><a class="header-anchor" href="#io和网络编程"><span>IO和网络编程</span></a></h3><p>Java 的 I/O 流是什么？</p><p>什么是 BIO、NIO、AIO？</p><p>什么是 Channel？</p><p>什么是 Selector？</p><p>什么是 Java 的网络编程？</p><h2 id="java高级特性" tabindex="-1"><a class="header-anchor" href="#java高级特性"><span>Java高级特性</span></a></h2><h3 id="注解和反射" tabindex="-1"><a class="header-anchor" href="#注解和反射"><span>注解和反射</span></a></h3><p>Java 中的注解原理是什么？<br><strong>注解</strong> 是一种元数据，用于提供程序元素（如类、方法、变量）的附加信息。注解本身不会直接影响程序的运行，但可以通过注解处理器在编译时或运行时读取这些注解并执行相应的操作。</p><p>主要组成部分</p><ol><li><p><strong>元注解</strong>：</p><ul><li><strong><code>@Retention</code></strong>：指定注解的保留策略（<code>SOURCE</code>、<code>CLASS</code>、<code>RUNTIME</code>）。</li><li><strong><code>@Target</code></strong>：指定注解可以应用的目标（如 <code>TYPE</code>、<code>METHOD</code>、<code>FIELD</code>）。</li><li><strong><code>@Documented</code></strong>：指定注解是否包含在 Javadoc 文档中。</li><li><strong><code>@Inherited</code></strong>：指定注解是否可以被子类继承。</li></ul></li><li><p><strong>自定义注解</strong>：</p><ul><li>使用 <code>@interface</code> 关键字定义。</li><li>可以包含属性（方法），属性可以有默认值。</li></ul></li></ol><p>注解处理器</p><ul><li><strong>编译时处理</strong>：使用注解处理器在编译时读取注解并生成代码或执行其他操作。</li><li><strong>运行时处理</strong>：使用反射机制在运行时读取注解并执行相应的操作。</li></ul><p>应用场景</p><ul><li><strong>编译时检查</strong>：如 <code>@Override</code>、<code>@Deprecated</code>。</li><li><strong>代码生成</strong>：如 Lombok 注解生成 getter 和 setter 方法。</li><li><strong>配置元数据</strong>：如 Spring 的 <code>@Autowired</code>、<code>@Component</code>。</li><li><strong>运行时行为</strong>：如 JUnit 的 <code>@Test</code>、<code>@Before</code>。</li></ul><p>你使用过 Java 的反射机制吗？如何应用反射？</p><div class="hint-container info"><p class="hint-container-title">Java反射</p><p>Java反射机制是Java语言提供的一种能够在运行时分析类和对象的能力。它允许程序在运行时动态地获取类的信息（如类名、属性、方法等），创建对象，调用方法，改变属性值等。 这对于开发一些需要高度灵活性和元编程功能的应用非常有用，比如开发框架、ORM工具、AOP（面向切面编程）等</p><ol><li><p><strong>获取 <code>Class</code> 对象</strong>：</p><ul><li><strong><code>Class.forName(String className)</code></strong>：通过类名获取 <code>Class</code> 对象。</li><li><strong><code>Object.getClass()</code></strong>：通过对象获取 <code>Class</code> 对象。</li><li><strong><code>Class&lt;T&gt; c = T.class</code></strong>：通过类字面量获取 <code>Class</code> 对象。</li></ul></li><li><p><strong>创建对象</strong>：</p><ul><li><strong><code>Class.newInstance()</code></strong>：创建类的实例（Java 9 以后不推荐使用）。</li><li><strong><code>Constructor.newInstance(Object... initargs)</code></strong>：通过构造器创建类的实例。</li></ul></li><li><p><strong>获取和调用方法</strong>：</p><ul><li><strong><code>Class.getMethod(String name, Class... parameterTypes)</code></strong>：获取公共方法。</li><li><strong><code>Class.getDeclaredMethod(String name, Class... parameterTypes)</code></strong>：获取所有方法（包括私有方法）。</li><li><strong><code>Method.invoke(Object obj, Object... args)</code></strong>：调用方法。</li></ul></li><li><p><strong>获取和访问字段</strong>：</p><ul><li><strong><code>Class.getField(String name)</code></strong>：获取公共字段。</li><li><strong><code>Class.getDeclaredField(String name)</code></strong>：获取所有字段（包括私有字段）。</li><li><strong><code>Field.set(Object obj, Object value)</code></strong>：设置字段值。</li><li><strong><code>Field.get(Object obj)</code></strong>：获取字段值。</li></ul></li><li><p><strong>获取和访问构造器</strong>：</p><ul><li><strong><code>Class.getConstructor(Class... parameterTypes)</code></strong>：获取公共构造器。</li><li><strong><code>Class.getDeclaredConstructor(Class... parameterTypes)</code></strong>：获取所有构造器（包括私有构造器）。</li></ul></li><li><p><strong>设置访问权限</strong>：</p><ul><li><strong><code>AccessibleObject.setAccessible(boolean flag)</code></strong>：设置是否允许访问私有成员。</li></ul></li></ol></div><h3 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h3><p>Java 泛型的作用是什么？</p><p>Java 泛型擦除是什么？</p><p>什么是 Java 泛型的上下界限定符？</p><h3 id="异常和错误" tabindex="-1"><a class="header-anchor" href="#异常和错误"><span>异常和错误</span></a></h3><p>Java 中 Exception 和 Error 有什么区别？</p><p>Java 运行时异常和编译时异常之间的区别是什么？</p><p>Java 中 final、finally 和 finalize 各有什么区别？</p><h3 id="jdk8新特性" tabindex="-1"><a class="header-anchor" href="#jdk8新特性"><span>JDK8新特性</span></a></h3><p>JDK8 有哪些新特性？</p><p>Java 的 Optional 类是什么？它有什么用？</p><h3 id="lambda-stream" tabindex="-1"><a class="header-anchor" href="#lambda-stream"><span>Lambda&amp;Stream</span></a></h3><h3 id="spi机制" tabindex="-1"><a class="header-anchor" href="#spi机制"><span>SPI机制</span></a></h3><p>什么是 Java 的 SPI（Service Provider Interface）机制？</p><h3 id="调用外部程序" tabindex="-1"><a class="header-anchor" href="#调用外部程序"><span>调用外部程序</span></a></h3><p>如何在 Java 中调用外部可执行程序或系统命令？</p>',54))])}const J=o(p,[["render",g],["__file","base.html.vue"]]),b=JSON.parse('{"path":"/interview/java/base.html","title":"Java基础","lang":"en-US","frontmatter":{"order":1,"title":"Java基础","description":"Java基础知识 你认为 Java 的优势是什么？ 在过去Java因其 跨平台，垃圾回收，面向对象 等特点而流行起来，到现在形成了 成熟的生态 ，拥有完善的工具，框架和中间件，以及大量的专业人才，我觉得这才是Java现如今最大的优势和竞争力。 JDK 和 JRE 有什么区别？你使用过哪些 JDK 提供的工具？ JRE指的是Java运行环境，包含了 JV...","head":[["meta",{"property":"og:url","content":"https://x.app/interview/java/base.html"}],["meta",{"property":"og:site_name","content":"Notebook"}],["meta",{"property":"og:title","content":"Java基础"}],["meta",{"property":"og:description","content":"Java基础知识 你认为 Java 的优势是什么？ 在过去Java因其 跨平台，垃圾回收，面向对象 等特点而流行起来，到现在形成了 成熟的生态 ，拥有完善的工具，框架和中间件，以及大量的专业人才，我觉得这才是Java现如今最大的优势和竞争力。 JDK 和 JRE 有什么区别？你使用过哪些 JDK 提供的工具？ JRE指的是Java运行环境，包含了 JV..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-28T13:29:58.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2024-11-28T13:29:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-28T13:29:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Java基础知识","slug":"java基础知识","link":"#java基础知识","children":[{"level":3,"title":"Java数据类型","slug":"java数据类型","link":"#java数据类型","children":[]},{"level":3,"title":"Java字符串对象","slug":"java字符串对象","link":"#java字符串对象","children":[]},{"level":3,"title":"Java面向对象","slug":"java面向对象","link":"#java面向对象","children":[]},{"level":3,"title":"方法和参数传递","slug":"方法和参数传递","link":"#方法和参数传递","children":[]},{"level":3,"title":"接口和抽象类","slug":"接口和抽象类","link":"#接口和抽象类","children":[]},{"level":3,"title":"深浅拷贝","slug":"深浅拷贝","link":"#深浅拷贝","children":[]},{"level":3,"title":"内部类","slug":"内部类","link":"#内部类","children":[]},{"level":3,"title":"Object类中的方法","slug":"object类中的方法","link":"#object类中的方法","children":[]},{"level":3,"title":"equals/hashCode","slug":"equals-hashcode","link":"#equals-hashcode","children":[]},{"level":3,"title":"IO和网络编程","slug":"io和网络编程","link":"#io和网络编程","children":[]}]},{"level":2,"title":"Java高级特性","slug":"java高级特性","link":"#java高级特性","children":[{"level":3,"title":"注解和反射","slug":"注解和反射","link":"#注解和反射","children":[]},{"level":3,"title":"泛型","slug":"泛型","link":"#泛型","children":[]},{"level":3,"title":"异常和错误","slug":"异常和错误","link":"#异常和错误","children":[]},{"level":3,"title":"JDK8新特性","slug":"jdk8新特性","link":"#jdk8新特性","children":[]},{"level":3,"title":"Lambda&Stream","slug":"lambda-stream","link":"#lambda-stream","children":[]},{"level":3,"title":"SPI机制","slug":"spi机制","link":"#spi机制","children":[]},{"level":3,"title":"调用外部程序","slug":"调用外部程序","link":"#调用外部程序","children":[]}]}],"git":{"createdTime":1731760951000,"updatedTime":1732800598000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":2}]},"readingTime":{"minutes":15.24,"words":4572},"filePathRelative":"interview/java/base.md","localizedDate":"November 16, 2024","autoDesc":true}');export{J as comp,b as data};
